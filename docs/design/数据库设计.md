# 数据库设计

## 0. 用户信息

### 0.1. django auth_user 表

- 记录用户数据，已经由 django 自动生成

#### 0.1.1. 关键字段：

- id
- password
- username
- email

* 注意，我们需要把自己设置为 superuser，每个人有一个账号

### 0.2. django auth_user_group 表

- 记录用户队伍，已经由 django 自动生成

#### 0.2.1. 关键字段：

- id
- user_id
- group_id

## 1. 排名应用 Rank

### 1.1. 用户表 user

- 扩展 django 的 auth_user，记录用户信息，分数等

| 序号 |     字段     |  类型  | 约束 |     说明     |                                 备注                                 |
| :--: | :----------: | :----: | :--: | :----------: | :------------------------------------------------------------------: |
|  1   |      id      | Serial |  PK  |     编号     |                             系统唯一标识                             |
|  2   |   user_id    | Bigint |  FK  |   用户 id    |                          auth_user 中的 id                           |
|  3   | total_points |  int   |      | 用户所得总分 |      根据 answer_record 表中的答题记录计算，每次答题正确时更新       |
|  4   |     rank     |  int   |      | 用户个人排名 | （不一定需要此列）根据 total_points 得出，每次用户答题正确的时候更新 |

#### 业务逻辑

1. (BE)（存在问题）rank 列或许可以不在后端设置，因为维护数据比较繁琐（每次有人答题，要更新所有人的 rank），前端显示是现实所有人的排名，不如按 points 顺序返回数据，前端自动生成排名
2. (FE)（解决上述问题的一个方法）前端显示根据后端数据返回的分数自动排出所有人的排名（可通过 js 实现），在 Rank 页面显示
3. (BE) 检索用户时，用用户名检索，允许模糊检索
4. (BE) 我们可以把自己设置为 is_superuser

### 1.2. 队伍表 team

- 扩展 django 的 auth_user_groups，记录队伍信息，分数

| 序号 |    字段     |  类型   | 约束 |       说明       |                                 备注                                 |
| :--: | :---------: | :-----: | :--: | :--------------: | :------------------------------------------------------------------: |
|  1   |     id      | Serial  |  PK  |       编号       |           系统唯一标识，写入 auth_user_groups 的 group_id            |
|  2   |  team_name  | Varchar | UNI  |     队伍名称     |                 创建队伍的时候填写，应该提供修改功能                 |
|  3   |  leader_id  | Bigint  |      |     队长 id      |                       队长在 auth_user 中的 id                       |
|  4   | team_member |   int   |      |     队伍人数     |
|  5   | allow_join  | Boolean |      | 是否允许他人加入 |                    如果不可加入，则只可以队长邀请                    |
|  6   |    rank     |   int   |      |   用户个人排名   | （不一定需要此列）根据 total_points 得出，每次队员答题正确的时候更新 |

#### 业务逻辑

1. (BE)（存在问题）rank 列或许可以不在后端设置，team 表并没有直接保存队员 id（因为队员数量不可知），且难以维护（每次有人答题，要更新所有人的 rank）
2. (FE)（解决上述问题）前端显示根据后端数据返回的分数自动排出所有队伍的排名，在 Rank 页面显示
3. (BE) 用户创建队伍时，在 team 表新建一行，将自己的 id 设置为 leader_id，将 id 设置为 auth_user_group 的 group_id
4. (FE, BE) 用户输入队伍名检索队伍，后端只返回符合检索且 allow_join 为 true 的数据
5. (BE) 检索队伍名允许模糊检索
6. (BE) 用户加入队伍时，在 auth_user_group 新建一行，group_id 为 team 表中该队伍的 id
7. (FE) 需要队长给队伍添加人员的前端页面，队长输入队员的 id 来添加队员
8. (BE) 查询用户属于哪个队伍的时候，需要查询 auth_user_group 表，将 group_id 符合的 user_id 集合返回

## 2. 题目应用 tasks

### 2.1. 题目表 task

- 记录题目信息，包括题目的唯一标识，题目类型，供查询

| 序号 |    字段    |  类型   | 约束 |     说明      |                               备注                                |
| :--: | :--------: | :-----: | :--: | :-----------: | :---------------------------------------------------------------: |
|  1   |     id     | Serial  |  PK  |     编号      |                           系统唯一标识                            |
|  2   |  user_id   | Bigint  |  FK  |    用户 id    |                         auth_user 中的 id                         |
|  3   | task_name  | Varchar |      |   题目名称    |                                                                   |
|  4   |  content   |  TEXT   |      | 题目内容描述  |                     储存文本，格式由前端决定                      |
|  5   |   annex    | Varchar |      | 题目附件 url  |                       可以提供附件下载链接                        |
|  6   |    hint    |  TEXT   |      |     提示      |                       难题可以设置一下提示                        |
|  7   |    flag    | Varchar |      |     Flag      |                    需要做好数据保护（加密？）                     |
|  7   | difficulty |   int   |      | 题目难度 enum |               0 Easy <br /> 1 Medium <br /> 2 Hard                |
|  8   |   points   |   int   |      |   本题分值    |                                                                   |
|  9   |    type    |   int   |      | 题目类型 enum | 0 Misc <br /> 1 Pwn <br /> 2 Web <br /> 3 Reverse <br /> 4 Crypto |

#### 业务逻辑

1. (BE) 记录每个题目的 type 可以作为 filter，用户点击在前端不同类型题目的页面是，根据 type 过滤返回数据
2. (FE) 前端给管理员提供“部署题目”的页面

### 2.2. 答题记录表 answer_record

- 记录用户答题，如果用户正确答题，则添加一行记录，否则不添加数据

| 序号 |    字段    |   类型    | 约束 |       说明       |                         备注                         |
| :--: | :--------: | :-------: | :--: | :--------------: | :--------------------------------------------------: |
|  1   |     id     |  Serial   |  PK  |       编号       |                     系统唯一标识                     |
|  2   |  user_id   |  Bigint   |      |     用户 id      |                  auth_user 中的 id                   |
|  3   |  task_id   |  Bigint   |  FK  |   题目 id 编号   |                  task 表中的题目 id                  |
|  4   |   points   |    int    |      |     本题得分     |                根据 Task 表的 points                 |
|  5   | clear_time | Timestamp |      | 用户成功答题时间 | 收到前端 POST 之后，后端在处理的时候生成这条数据即可 |

#### 业务逻辑

1. (BE) 用户提交且答案正确，则添加一行
2. (FE, BE) 查询用户答题情况时，前端传入用户 id，后端用 filter 过滤查询，返回符合 user_id 的 task_id 集合
3. (BE) 要避免用户反复答题增加数据库无用数据，后端需对 user_id 和 task_id 进行检测，如果存在库表内，则忽略前端数据。
4. (FE) 前端在答题界面应该也做好设计，比如用户无法点击已经答过的题的提交按钮。可以通过获取用户已经答题的集合，将这些题对应的答题按钮的 enable 设置为 false
