# 数据库设计

## 0. 用户信息

### 0.1. django auth_user 表

- 记录用户数据，已经由 django 自动生成

#### 0.1.1. 关键字段：

- id
- password
- username
- email 用于邮箱验证

* 注意，我们需要把自己设置为 superuser，每个人有一个账号

### 0.2. django auth_user_group 表

- 记录用户队伍，已经由 django 自动生成

#### 0.2.1. 关键字段：

- id
- user_id
- group_id

## 1. 用户

### 1.1. 用户表 user

- 扩展 django 的 auth_user，记录用户信息，分数等

| 序号  |       字段       |   类型    |  约束  |       说明       |                           备注                            |
| :---: | :--------------: | :-------: | :----: | :--------------: | :-------------------------------------------------------: |
|   1   |        id        |  Serial   |   PK   |       编号       |                       系统唯一标识                        |
|   2   |       user       |  Bigint   | 一对一 |     用户 id      |                    auth_user 的主键 id                    |
|   3   |       team       |  Bigint   |   FK   |     队伍 id      |              team表的主键，队伍的时候为 None              |
|   4   |      score       |    int    |        |   用户所得总分   | 根据 answer_record 表中的答题记录计算，每次答题正确时更新 |
|   5   | last_answer_time | TimeStamp |        | 用户最后答题时间 |  作为排名的第二依据：分数相同，则先达到该分数的排名靠前   |

#### 1.1.1. auth_user 表

| 序号  |     字段     |       说明       |            备注            |
| :---: | :----------: | :--------------: | :------------------------: |
|   1   |      id      |       编号       |        系统唯一标识        |
|   2   |   password   |     用户 id      |     auth_user 中的 id      |
|   3   |  last_login  | 最后一次登录时间 |     调用login自动修改      |
|   4   | is_superuser |     用户权限     |      是否为超级管理员      |
|   5   |   username   |      用户名      |                            |
|   6   |  last_name   |                  |                            |
|   7   |    email     |       邮箱       |        用于邮箱验证        |
|   8   |   is_staff   |                  |                            |
|   9   |  is_active   |                  | 邮箱验证激活后才设置为True |
|  10   | date_joined  |     注册时间     |                            |
|  11   |  first_name  |                  |                            |


#### 业务逻辑

1. (BE)（存在问题）rank 列或许可以不在后端设置，因为维护数据比较繁琐（每次有人答题，要更新所有人的 rank），前端显示是现实所有人的排名，不如按 points 顺序返回数据，前端自动生成排名
2. (FE)（解决上述问题的一个方法）前端显示根据后端数据返回的分数自动排出所有人的排名（可通过 js 实现），在 Rank 页面显示
3. (BE) 检索用户时，用用户名检索，允许模糊检索
4. (BE) 我们可以把自己设置为 is_superuser

### 1.2. 队伍表 team

| 序号  |    字段     |   类型    | 约束  |       说明       |                 备注                 |
| :---: | :---------: | :-------: | :---: | :--------------: | :----------------------------------: |
|   1   |     id      |  Serial   |  PK   |       编号       |             系统唯一标识             |
|   2   |  team_name  |  Varchar  |  UNI  |     队伍名称     | 创建队伍的时候填写，应该提供修改功能 |
|   3   |   leader    |  Bigint   |       |     队长 id      |       队长在 auth_user 中的 id       |
|   4   | team_member |    int    |       |     队伍人数     |                                      |
|   5   | allow_join  |  Boolean  |       | 是否允许他人加入 |    如果不可加入，则只可以队长邀请    |
|   6   | create_time | TimeStamp |       |     创建时间     |        创建队伍时后端自动生成        |

#### 业务逻辑

1. (BE)（存在问题）rank 列或许可以不在后端设置，team 表并没有直接保存队员 id（因为队员数量不可知），且难以维护（每次有人答题，要更新所有人的 rank）
2. (FE)（解决上述问题）前端显示根据后端数据返回的分数自动排出所有队伍的排名，在 Rank 页面显示
3. (BE) 用户创建队伍时，在 team 表新建一行，将自己的 id 设置为 leader_id，将 id 设置为 auth_user_group 的 group_id
4. (FE, BE) 用户输入队伍名检索队伍，后端只返回符合检索且 allow_join 为 true 的数据
5. (BE) 检索队伍名允许模糊检索
6. (BE) 用户加入队伍时，在 auth_user_group 新建一行，group_id 为 team 表中该队伍的 id
7. (FE) 需要队长给队伍添加人员的前端页面，队长输入队员的 id 来添加队员
8. (BE) 查询用户属于哪个队伍的时候，需要查询 auth_user_group 表，将 group_id 符合的 user_id 集合返回

## 2. 题目

### 2.1. 题目表 task

- 记录题目信息，包括题目的唯一标识，题目类型，供查询

| 序号  |    字段     |  类型   | 约束  |     说明      |                               备注                                |
| :---: | :---------: | :-----: | :---: | :-----------: | :---------------------------------------------------------------: |
|   1   |     id      | Serial  |  PK   |     编号      |                           系统唯一标识                            |
|   2   |  task_name  | Varchar |       |   题目名称    |                                                                   |
|   3   |   content   |  TEXT   |       |   题目内容    |            可以直接储存 html 格式的内容，简化前端逻辑             |
|   4   |    annex    | Varchar |       | 题目附件 url  |                       可以提供附件下载链接                        |
|   5   |    hint     |  TEXT   |       |     提示      |                       难题可以设置一下提示                        |
|   6   |    flag     | Varchar |       |     Flag      |                    需要做好数据保护（加密？）                     |
|   7   | difficulty  |   int   |       | 题目难度 enum |               0 Easy <br /> 1 Medium <br /> 2 Hard                |
|   8   |   points    |   int   |       |   本题分值    |                                                                   |
|   9   |    type     |   int   |       | 题目类型 enum | 0 Misc <br /> 1 Pwn <br /> 2 Web <br /> 3 Reverse <br /> 4 Crypto |
|  10   | solve_count |   int   |       |   解出数量    |                                                                   |


#### 业务逻辑

1. (BE) 记录每个题目的 type 可以作为 filter，用户点击在前端不同类型题目的页面是，根据 type 过滤返回数据
2. (FE) 前端给管理员提供“部署题目”的页面

### 2.2. 答题记录表 answer_record

- 记录用户答题，如果用户正确答题，则添加一行记录，否则不添加数据

| 序号  |    字段     |   类型    | 约束  |       说明       |                         备注                         |
| :---: | :---------: | :-------: | :---: | :--------------: | :--------------------------------------------------: |
|   1   |     id      |  Serial   |  PK   |       编号       |                     系统唯一标识                     |
|   2   |    user     |  Bigint   |  FK   |     用户 id      |                  auth_user 中的 id                   |
|   3   |    task     |  Bigint   |  FK   |   题目 id 编号   |                  task 表中的题目 id                  |
|   4   |   points    |    int    |       |     本题得分     |                根据 Task 表的 points                 |
|   5   | answer_time | Timestamp |       | 用户成功答题时间 | 收到前端 POST 之后，后端在处理的时候生成这条数据即可 |

#### 业务逻辑

1. (BE) 用户提交且答案正确，则添加一行
2. (FE, BE) 查询用户答题情况时，前端传入用户 id，后端用 filter 过滤查询，返回符合 user_id 的 task_id 集合
3. (BE) 要避免用户反复答题增加数据库无用数据，后端需对 user_id 和 task_id 进行检测，如果存在库表内，则忽略前端数据。
4. (FE) 前端在答题界面应该也做好设计，比如用户无法点击已经答过的题的提交按钮。可以通过获取用户已经答题的集合，将这些题对应的答题按钮的 enable 设置为 false

### 2.3. 首杀记录表 first_kill

| 序号  |    字段     |   类型    | 约束  |       说明       |                         备注                         |
| :---: | :---------: | :-------: | :---: | :--------------: | :--------------------------------------------------: |
|   1   |     id      |  Serial   |  PK   |       编号       |                     系统唯一标识                     |
|   2   |    user     |  Bigint   |  FK   |     用户 id      |                  auth_user 中的 id                   |
|   3   |    task     |  Bigint   |  FK   |   题目 id 编号   |                  task 表中的题目 id                  |
|   4   | answer_time | Timestamp |       | 用户成功答题时间 | 收到前端 POST 之后，后端在处理的时候生成这条数据即可 |

## 3. 信息

### 3.1 信息表 Message

| 序号  |   字段   |  类型   | 约束  |        说明        |                       备注                        |
| :---: | :------: | :-----: | :---: | :----------------: | :-----------------------------------------------: |
|   1   |    id    | Serial  |  PK   |        编号        |                   系统唯一标识                    |
|   2   | receiver | Bigint  |  FK   |     收信人 id      |                 auth_user 中的 id                 |
|   3   |  origin  | Bigint  |  FK   |     送信人 id      |                task 表中的题目 id                 |
|   4   | message  | Varchar |       |      信息内容      |        如果长度不足，类型可以考虑改为 TEXT        |
|   5   |  check   | Boolean |       |   收信人接收状态   | 默认为False，收信人看过信息（打开信息栏）后为True |
|   6   |   type   |   int   |       | 信息类型，枚举实现 |                                                   |