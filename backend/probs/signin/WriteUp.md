# ezSignin

题目给了附件main.py，简单分析`handle`方法可以看出，只有通过post /login以admin用户登录，才能获取到flag。
当用户使用admin为用户名时，会被直接拦截。当用户名和密码相同时也会被拦截。
但是再仔细看，发现最终登录的用户名不是来源于请求，而是根据hash匹配到的用户，那可以构造一个和admin用户相同的hash来登录。
跳转到`gethash`函数可以发现，这个hash实际上是用户名和密码分别加盐计算md5后，异或得到，下面的两个assert也表面admin用户的密码也是admin,即用户名和密码相同，加盐后的字符串也相同，md5就相同，异或的结果就是0，因此只要选择一对用户名和密码，使他们对应的字符串相同。
回到`handle`发现用户名和密码是json反序列化出来的，并且没有做类型检查，也就是说这两个字段的类型是可以不一样的，而不同类型在python下不会相等，也就绕过了不允许用户名密码相同的限制。
因此可以构造出一个能登录的params:
```json
{
    "username":"0",
    "password":0
}
```
之后就是构造请求并发送给服务器。
可以看到这个json是payload里的params字段通过`decrypt`函数得到的，但是看这个`decrypt`函数，看起来是做了5次base64编码得到结果，但是输入的就是一个base64编码的结果，而输出是一个json,所以可以推断这个`base64.b64encode`有问题。
往上翻可以看到一段奇怪的代码
```python
eval(int.to_bytes(0x636d616f686e69656e61697563206e6965756e63696165756e6320696175636e206975616e6363616361766573206164^8651845801355794822748761274382990563137388564728777614331389574821794036657729487047095090696384065814967726980153,160,"big",signed=True).decode().translate({ord(c):None for c in "\x00"})) # what is it?
```
看不懂没关系，把eval去掉执行一下就知道了，执行得到结果`'[[0] for base64.b64encode in [base64.b64decode]]'`，可知实际上`base64.b64encode`应该是`base64.b64decode`才对，剩下就没有难点了，直接构造payload获得flag

修复思路，因为login成功后会返回一个hash,所以通过修改gethash的思路就不太行，但是可以通过限制username和password字段的类型，使得gethash加盐后的字符串不可能一致即可